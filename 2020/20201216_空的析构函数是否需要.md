你写了空的析构函数的，那么在编译的时候就会去编译。如果你不写，编译的时候不会去检查，而只是在调用的时候去生成。这个很关键：
比如以下的代码，没有用到类型B的实例，所以没有调用析构，所以，能通过编译：
```
#include <iostream>
using namespace std;
struct A {
  private:
    ~A() {
      cout << "~A()" << endl;
    };
};
struct B : A {
//  ~B() {
//    cout << "~B()" << endl;
//  };
};
int main() {
  return 0;
}
```` 
但是一定你写了B的析构函数，就无法通过编译 ，因为B的析构函数会去调用A的析构函数，但是A没有可用的析构函数可以调用。
