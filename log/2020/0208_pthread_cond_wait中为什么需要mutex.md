关于pthread_cond_wait这个接口，unix环境高级编程上有一段说明:

pthread_cond_wait需要mutex来保护条件变量，因为mutex可以保证原子得执行下面两个操作:

1. 调用线程检查条件变量。
2. 把自己放到条件变量的等待线程队列并进入阻塞状态。

这样就可以避免调用线程在检查条件并进入阻塞状态期间，其他线程调用pthread_cond_signal，使得信号时没有被阻塞线程收到。

这段话的主要意思是，通过mutex来保证线程发信号时，另外一个线程已经完成检查并进入阻塞状态。
也就是说，一个线程在检查条件变量时先持有mutext，这样其他线程就没法signal，因为可以通过编码来实现在signal前先获取mutex。



查过这个接口的man文档，文档里提到，这个接口可以保证释放mutex并阻塞在条件变量上这个过程的原子性。这个解释好像比《unix环境高级编程》里说的更准确一些。不过好像说的是同一个意思。

**本质上就是要实现，线程释放锁进入等待状态，这个过程中不会发生别的线程并发送信号，因为如果发生，那么这个信号无法被前面的阻塞线程接收到。**

但这也许并不是pthread_cond_wait需要传入mutex的根本原因，这个接口自己就应该能保证：检查条件变量并进入阻塞状态等信号这个过程的原子性。

因为这两个操作本身和mutex有什么关系呢？而且pthread_cond_signal调用接口本身也不和mutex关联，是程序员自己来保证调用前先获取mutex。


从功能上来说，还有一个地方的原子性比较重要：（1）被告知条件变量满足，线程唤醒并再次持有mutex锁。这两个操作必须一同完成。也许释放mutex线程阻塞的原子性，和唤醒并再次持有锁的原子性都重要。

之所以需要mutex，关键还是在于业务本身需要互斥，只是这个需要时间来触发而已，如果只是一个信号，没法保证业务上的原子性。单单收发信号的原子性并不能解决业务的互斥问题。所以需要通过引入mutex来进行线程同步，mutex是功能的根本，毕竟解决线程之间的同步才是目的。
