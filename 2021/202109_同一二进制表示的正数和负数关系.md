在计算机中，一个整数的存储可以有不同类型的解析，你可以解析为有符号数，也可以解析为无符号数。
对于一个二进制表达，在确定位数的情况下，如果第一位不是1，那么不管把他解析为有符号数，还是无符号数，那么结果都是整数。
而只有第一位是1的二进制表达，解析为有符号数时是负数，无符号数时是整数。那么现在的问题是，这两个数之间有什么关系？

通过计算机计数的基本原理，不管一个数是符号还是无符号，二进制标的上的多1，一定也是数值上的多1。也就是说，对于8位的整数来说。
141对应的有符号数（负数） = 140 对应的有符号负数 + 1，这个规则总是成立的。
通过编程，我们知道，141对应的有符号数时-115,140对应的有符号数是-116，所以-115 = -116 + 1。

为什么会这样，因为在我看来，计算机内部一直都认为，二进制表达和数值表达，在没有溢出的情况下是需要一致的。
二进制上加1是表示在增加的，只要没有溢出。11111111在加1变成00000000，只要没溢出，00000000就是比11111111大1的。
但是对于无符号来说11111111是上限，是不保证二进制的语义和数值语义一致的。所以无符号数中00000000并不比11111111大1。

但是对于有符号来说，11111111是并不是数值上的边界值，这是有符号数的语法解析来定义的。
在这种解析规则下，111111111是数值上的-1，在范围内，是需要满足二进制加1就导致数值+1的规则的。
也就是说，数值上需要和二进制表达上的语义一致。

那么为什么有符号数不把11111111定义为-127，而是定义为-1呢？我个人的理解是，就刚才说的，这个违法了二进制和数值上的一致性。
我们知道，对无符号数来说，11111110 二进制加1，变成11111111，对应的无符号数也是加1的。

但是，吴国我们把111111111定义为-127,那么-126是多少呢？是111111110。数值上是加1。但是二进制却是-126的二进制加1变成-127的二进制。
这是想法的，或者说二进制上的+1,却是导致数值上的-1。也许这种不一致会导致累加器上的一些实现上的复杂性。

所以，基于同一的规则，二进制上的+1，永远对应数值上的+1，这条一致性规则，我们可以总结出，同一个二进制表达，假设整数是p,负数是n，那么两者的关系是。
```
p + |n| = 2^x
```
或者说是
```
p - n = 2^x
```
所以我们知道，
一个8位的无符号数，159，要解析为有符号数，那一定是 159 - 256 = -97.
