
## 编码建议
#### 平台性能组 v0.824

## 目录
- [说明](#说明)
- [命名](#命名)
- [格式](#格式)
- [头文件](#头文件)
- [函数](#函数)
- [日志](#日志)
- [命令](#命令行)
- [性能](#性能)
- [自查](#自查)


## 0. 说明
这是一份组内的编码建议，目的是让代码有更加一致的风格，使得组内代码更加易于维护，同时问题单流程能更加有效。
这份主要的参考[Google C++ 编码规范](https://google.github.io/styleguide/cppguide.html)

## 防御性编程
这是我自己想出来的一个词，用来反应我自己编码总体原则的理解。

## 基本原则
#### 最优原则
任何代码，都只是各种方案中的一种实现，没有绝对的最优选择，但代码都有相对合理的位置，请注意下面两个问题：
- 找到最适合实现这个功能的模块（为代码块找到最合适的类，并分装为类的成员函数，为类找到最合适的模块，并成为模块的组件）
- 找到最适合编写这行代码的位置（为代码找到在函数中最合适的位置）

#### 受控原则
受控包括时间受控，内存受控，CPU受控。这是一个常常不受注意的点，我们写代码，很多时候容易写出不受控制的代码。
比如如果使用协程，一个请求来，创建一个task。如果因为某些原因，这些task无法及时推出，那么创建的task数量就可能极大。
一个task如果分配1M空间，那很容易就占满内存。一切都是受控的，操作系统，或者标准库能提供的受控之外，所有的资源都要再代码中受控。
这样的编程才是安全的。


## 1. 头文件
#### `#define`保护
- 所有头文件都应该使用`#define`来防止头文件被多重包含。
- `#define`宏的命名格式应该基于项目代码树的全路径，格式为`<PROJECT>_<PATH>_<FILE>_H_`

#### 前置申明
- 尽量避免使用，如果要用，一定要明确原因。

前置申明的缺点：
- 前置申明隐藏了依赖关系，改动头文件，用户代码会跳过必要的重新编译过程。
- 极端情况下，用前置申明会隐含得改变代码的含义。（见参考文档1.3）

#### 内联函数
```
只有当函数代码小于10行时，才将其定义为内联函数。
```
注意：
- 谨慎对待析构函数的内联，因为析构函数通常比其便面看起来更长。
- 一个经验准则时，内敛包含循环或者`switch`语句的函数通常得不偿失。

#### `#include`路径以及顺序
- 头文件包含建议顺序：相关头文件，`C`库，`C++`库，其他库头文件，本项目内的.h文件，每类内按字母排序。
- 避免使用快捷目录，比如`.`后者`..`

注意：
- 你所依赖的符号(symbols)被哪些头文件所定义，你就应该包含哪些头文件，就算你已经包含的某个头文件中会间接包含那个头文件。
- 但是，如果cc文件对应的相关头文件(即对应的同名h头文件)已经包含那些头文件，那是不需要再次包含进cc文件的。


## 2. 作用域
- 鼓励在`.cc`文件内使用匿名命名空间，或者`static`申明。


## 3. 类
#### class 还是 struct
- 除非只是数据的汇聚且没有完整性约束，否者都用`class`，不要用`struct`。
- 类将所有成员定义为`private`，尽量不要用`public`。

我自己比较简单的一个规则是，如果这个结构除了构造函数外还需要别的接口，那么这个结构就定义为class。

#### 类声明顺序
- 类中声明顺序：类型，常量，工厂函数，构造函数，赋值运算符，析构函数，其他函数，数据成员。

#### 数据强转
- 强转`(uint64_t)-1`这种方式可以接受，社区中有这种写法。


## 4. 函数
#### 优先用返回值而不是输出参数。

很多时候，很多规范会建议我们用输出参数来输出，但是返回值显然有更好的可读性。
原先建议用输出参数的一个理由是性能。但现在版本的C++编译器版本已经通过返回值优化等手段让return一样有非常高的效率。

#### 优先返回值类型或者引用。避免返回指针，除非这个指针允许为null。
在C++中，指针常常是不安全的，而相对来说，对象是安全的。所以多用对象和引用，少用指针。

#### 输入输出参数用引用还是指针
- 对于non-optional的输入参数（iparams），一般用值类型，或者`const`引用。
- 对于non-optional的输出参数（oparams）或者输入输出参数（ioparms），在参数不能为null时，一般用non-const引用。
- 对于optional的输入参数（iparams），用`absl::optional`来代表值类型输入参数，用一个const指针来对应可选输入参数中的cons引用。
- 对于optional的输出参数（oparams）或者输入输出参数（ioparms），用non-const指针表示。

对于以上的分类，我们知道，必选的参数意味着，对象必须是存在的，此时我们用引用。而对于可选的，允许对象不存在的场景，我们用指针。
所以，我们可以简单说，如果这个参数是允许`null`的，那么就用指针，否者用引用。然后根据是不是入参决定要不要用`const`。

#### 避免定义这样的函数：要求const引用参数的生命周期长于调用周期
因为const应用是绑定到一个临时的对象上，调用结束之后，const引用参数绑定的对象就会释放掉。
有时候确实会发生这种问题，比如函数试图返回一个参数的引用，这显然是不合理的。
在这种情况下，你就需要消除这种对lifetime的要求，比如把引用对象的值拷贝出去。
或者用const指针传入参数，并把lifetime和non-null约束文档化。


#### 输入和输出参数的顺序
- 输入参数在前，输出参数在后。

我们要特别注意，在加入新的参数时，不要因为他们是新加入的参数，就放在参数列表最后。
而是仍然按照参数的先后规则进行排列，将新的输入参数放在输出参数之前。同时作为输入输出参数的情况让这个问题变得更加复杂。
有时候，我们也为了和项目中其他已经存在的同类函数的参数顺序保持一致而不得不有所变通。


#### 尽量编写简短的函数
我们承认长函数有时是合理的, 因此并不硬性限制函数的长度. 如果函数超过 40 行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割。


#### 我们倾向于编写无返回值的函数
- 尽量定义无返回值的函数，简化异常处理。


#### 函数重载
- 重载函数尽量使用不同数量的参数，如果数量相同，只是启动的类型不同，需要编码者和使用者非常熟悉C++的匹配规则，有一定难度。
- 如果重载函数只是为了支持不同的参数个数，且这些参数的类型相同，那么可以考虑用`std::vector`以便使用者可以用`list-initialization`来指定参数。


#### 缺省参数
- 一般建议用函数重载，而不是使用缺省参数，但是缺省参数在non-virtual函数中允许的，并且要保证所有的默认参数含有相同的值。


#### 函数的参数避包含重复的字段
- 函数参数中，多个参数尽量避免在参数内部有重复的字段。
比如：
```
void DataManager::dm_write_obj_data(
  const hobject_t &hobj,
  const dm_data_oper_t &oper,
  const bufferlist &data
  )
```
这个接口中，`hobject_t` 和 `dm_data_oper_t` 两个参数类型中有相同的字段`object_t oid`, `string nspace`，设计不够好。
但是这个接口调用的接口需要hobject_t类型。即有时，函数内部依赖的其他接口的参数要求，导致我们设计的函数参数选择有限。

#### 函数流控
- 一个函数内条件语句嵌套不要超过2层，超过考虑用反向处理。
- 支持受限使用`goto`。

#### 内联控制
- 类函数如果不打算内联，就不要放在头文件里，而是放到对应的`cc`文件里，贯彻定义和声明分离原则。

#### 分支循环
- `for`或`while`的空循环体用空括号或者`continue`，不要只写一个分号。
- `switch-case`中的`default`中如果永远执行不到，应该加条`assert`，每一个`case`可以用大括号括起。
- 多重循环，最忙的循环放在最内层。
- 一般写成`if (ptr)` 而不是 `if (ptr != nullptr)`。



## 5. 命名
#### 命名通用规则
- 函数命名，变量命名，文件命名要有描述性，少用缩写。但`num`，`dns`，`ip`等常见写法除外。

#### 文件名命名
- 文件名全小写，建议用下划线(`_`)连接。

#### 命名空间
- 命名空间以小写字母命名，并注意和常见的顶级命名空间的名字发生冲突。
- 命名空间不使用缩写，命名空间里的类和结构不缩进，嵌套时每个命名空间独立一行。

#### 类型命名
- 建议每个单词首字母大写，且不包含下划线，类似`MyExcitingClass`。

#### 变量命名
- 变量以及函数参数，统一使用小写字母，单词之间用下划线连接。
- 类中的私有成员变量以下划线开始，如 `string _table_name`，这样函数就可以传入同名参数。
- 结构体的数据成员不一下环线开始, 如`int num_entrires`。
- 循环变量建议用iter作为前缀或者后缀命名变量。

#### 常量命名
- 申明为`constexpr` 或者 `const` 的变量，命名时以全大写并以下划线连接，比如:
```
const int SECONDS_IN_MIN = 60
```
- 或者命名时以`const`开头并且单词用下划线连接，比如：
```
const int const_hours_in_day = 24
```

#### 函数命名
- 常规函数用小写字母以及下划线连接。
- 函数命名以动词开始。
- 函数命名动词要准确。
比如，让挂起的destage-task继续处理新的事务，可以用`wakeup_destage_task()` 而不要用`start_destage_task()`，免得误以为要启动一个新的task。

#### 枚举命名
- 同宏一致，用全大写和下划线，比如`ENUM_NAME`。

#### 宏命名
- 不要使用宏，如果一定要用，用全大写和下划线。

#### 标签命名
- label可以选用简单常见的单词，比如`out`，`done`，`retry`，`again`，`fail`等。


## 6. 注释
- 函数头部必须注释。
- 命令行相关函数必须要把命令行用法写入注释。
- 单行以及多行注释统一用`//` 出了文件头注释，别处都不用 `/**/。
- 适当使用`TODO`注释。


## 7. 格式
#### 行长度
- 每一行代码字符数不超过80字符，命令行示例或者`URL`除外。

#### 空格还是制表位
- 缩进只用空格不用制表符，每次缩进2空格。

#### 函数申明和定义
- 函数不建议超过200行。
- 函数名与左圆括号之间永远没有空格，右圆括号和左大括号之间总是有一个空格。
- 函数参数列表中，入参在先，出参在后，新加入参数也要按此顺序，但有时需要与其他函数一致。
- 缺省缩进为 2 个空格，换行后的参数保持 4 个空格的缩进。

#### 分支判断
- `if/else/while/for/switch`等条件语句与左圆括号有空格
- 条件语句或者循环体重如果只有一条语句，也要用大括号括起。
- -左大括号换行写。

#### 指针或引用符号的位置
- 星号或者取地址符号与类型或者变量名挨着都可以，但是建议与变量名挨着。


## 惯用实践
### 断言的使用
### C++语法特性
#### 多用const
- 比如 `for (const auto& kv : metadata)`，注意`const`。

#### 多用列表初始化
- 可以用列表来初始化数组和结构体，在`C++03/C++11`中任何对象都可以。

#### 用nullptr指针
- 整数用`0`，实数用`0.0`，指正用`NULL`（`C++03`项目）或者`nullptr`（`C++11`项目）。

### 数据访问
#### 指针多层访问
- 如果有多处使用多层指针访问，那么需要用临时变量保持多层指针访问的值，比如循环判断中存在多层指针访问。
- 
###  规格
#### 字串长度规格
- 建议字符串长度规格设计成2的幂次方-1，即不包括字符串结尾的`\0`。

## 模式
#### 如果某一块代码都是围绕某个对象做的处理，那么就应该为这个对象编写单独的成员函数
比如 `Destage::delete_operation() ` 里的功能都是针对`destage_view`对象的操作，那么就应该编写`destage_view_t`的成员函数。
封装是一个最基本的原则，但是在实际的编码中，常常做的不够，数据的分装为合理的对象，流程分装为合理的接口，都需要仔细想想。


### 日志
当我们在代码中添加一行日志的时候，问自己一个问题：这行日志是为了定位什么问题。
我们添加日志，不是为了随便打印一些数据字段，而是去预判可能会出问题的地方，比如调用第三方接口可能会超时没有返回。
或者，我们需要标记当前被挂起的的具体的某个信号量，而不是只是打印有信号量被挂起。
当我们明确添加的每一行日志所针对的的问题时，我们的日志添加就会更加合理和有效。

#### 接口日志的完备性
- 一个接口中的日志尽量做到MECE原则，即是相互独立，完全穷尽。

在一个接口中，我们不要打印重复的数据字段，除非这个数据的值发生变化而且有必要。
也不要一行打印一个或几个字段，而是有效组织单行日志，让一行日志成为一个整体，每一行日志都有针对诊断某个问题。
所以，每一行日志都有关键信息的同时，尽量能组织更多的信息，减少接口中日志代码的行数，减少日志对模块性能的影响。


有时候，为了方便对日志进行行过滤，会在接口中的大多数行中打印相同的信息，比如都打印对象名方便过滤。
但是我个人觉得，这不是一个好的办法，这违反MECE原则。
如果我们要查看某个特定对象在该接口中的处理情况，我们可以通过`grep -A/-B/-C`等选项达到类似的效果。

#### 日志中的单词注意点
日志中的，如果不是确定的异常，正常场景的日志不应该选用`failed`，`error`等单词，以免在问题定位时误导分析，只有在比较确定出现故障的情况下，才使用这些关键字。

#### 分割符号
- 日志中建议多用冒号，逗号和分号进行分割，日志更清晰。

## 性能计数器
#### 考虑使用性能计数器的地方
1. 在调用其他模块接口处，如果这个接口可能存在性能问题，那么在这个地方考虑用性能计数器。
2. 在流程可能挂起后又等待唤醒的流程点，考虑使用新能计数器 一方面可以知道挂起的次数，跟关键的是可以得到平均的等待时长。

## 命令行
#### 命令连接符选择
用连字符，而不是下划线。如果一个命令需要几个单词连接，那么命令建议用连字符，而不是用下划线。
因为在终端敲命令时，下划线容易被看成是空格，这样单个命令有可能被误解为多个命令。我们可以发现，git工具所涉及的系列命令也是用连字符的。

## 代码自检
### 代码写完后的自我检查
#### 对每一个可能走到这行代码的流程：
- 这行代码对线程的同步异步是否有影响。
- 这行代码对流程的异常处理是否有影响。
- 这行代码对这个流程的性能是否有影响。

#### 对于受这行代码影响的每一项数据：
- 检查下这些数据是否有关联的数据需要同步修改。
- 检查下访问到这些数据的其他流程是否受到影响。


### 问题单电子流
#### 验证报告
- 验证报告应该实际操作确认，尽量完全模拟提单的流程步骤。
- 对于有的难以复现的问题单，可以考虑用单元测试进行覆盖。

## 常见的编程场景
#### 多路并发同步问题
- 问题场景：
1. 整个服务器的start/shutdown 和服务内个各个模块start/shutdown的同步问题。
2. 作为中心模块，收其他模块的信号触发，又会触发其他模块，多个模块之间有时序要求。

- 解决思路

#### 资源受控问题
- 问题场景
1. 对外接口会创建的线程，如果无限制调用，就会导致内存资源耗尽。

- 解决思路
