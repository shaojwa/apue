多路转接是高级IO中很常见的功能，说到多路转接，就不得不说select和poll，今天我们就来简单说下：

#### IO类型的分类
这一直是一个比较混乱的问题，阻塞，非阻塞，同步，异步，这么多概念，我们知道他们之前的微妙关联么？我觉得是困难的。
什么是阻塞？不阻塞就一定好么？在回答这些问题之前，我们先明确定义，什么是阻塞。

#### 什么是阻塞
阻塞，我的理解是，调用这个接口不会马上返回，可能会等待一段时间。什么时候返回？可能是有数据，或者是收到什么信号。
那么我们是否可以简单划分为，不是马上返回的就是阻塞的？我们暂时这么理解。

#### 不阻塞一定好么？
不一定，一个IO接口每次调用，都马上返回，但是没数据，这对程序来说就是高效率么？不一定的，没数据返回，我们总要处理吧。
怎么办，很多时候只能再来一次，那就是轮询，但是我们知道，轮询在大多数时候，都是比较浪费CPU的。所以，不阻塞不一定就是好的。

#### 不阻塞就是异步么？
不是的，不阻塞你还是要轮询，等到有数据之后，你才能往下走，从某种意义上来说，这是同步的。数据不到，我没法执行别的代码，这既是同步。
所以，同步还是异步，很多时候，不是借口的性质，而是实现的方式。同步IO，那么接口可以是阻塞，也可以是非阻塞。但是异步IO，那接口必然是非阻塞的，需要马上返回。
所以，阻塞非阻塞和异步同步，没有必然关系。

#### 为什么需要多路转接
好了，之前说了这么多，现在我们想一下，为什么我们需要多路转接，其实主要的动因不是阻塞非阻塞，而是我们有一个问题。
如果只用read，write的阻塞模式，我们没法在一个进程（Linux下用线程更合适）中同时读多路数据，比如我没法同时处理两个输入。
要处理两个fd，我们只能创建两个线程，进行阻塞式IO，这是一个严重的问题。因为这增加了程序的复杂性，按照APUE说法，多个线程之间总会有一些同步问题。

那么非阻塞模式怎么样？可以的，read轮询，有数据就读取，没有数据就询问下一个。功能上是可以的，毕竟在没有引入select之前，也得实现功能不是。
所以，只要是对非阻塞时IO支持的系统，轮询机制也是可以的。但是，毕竟我们很难控制等待多久去轮询，以及轮询模式的CPU资源浪费问题也很明显。

好的，非阻塞式的轮询不行，那我异步IO行么？没有数据我就继续执行，注册处理函数，当有数据时，调用我的回调函数来处理，典型的异步机制。
可不可以？可以的，但是我怎么知道是哪个fd有数据呢？我们可用的信号量是有限的，如果一个进程中，可以用信号来区别fd，但是，这无法应对大量fd的场景。
也就是说，fd不能和信号类型关联。那么能不能不关联，只有当数据过来时，通知我们自己去确认是哪个fd可用？我觉得是可以的。
只要我们把多个fd设置为非阻塞，然后所有数据通知我们。

所以，现在的关键是，我们怎么对多个fd进行统一的监听？可以的，你想要的，内核都会支持你。这个特性的关键是什么，应该是多路，所以这个特性翻译过来叫
多路转接（multiplexing）

#### multiplex
这个是本来是通信工程中的概念，意思就是一个通道发送两个或者多个信号或者消息。

#### 多路转接的模式
现在我们可以监听多个fd，那么具体还是有很多细节可以考虑？最简单的就是阻塞还是不阻塞？没关系，select都可以做到，只要你给合适的参数。
select就能支持你希望的机制，轮询，还是死等。

#### select的问题
好，select初步实现了多路转接，他可以统一监管了，统一上报（只要有一个满足条件），他的监听的fd范围也达到1024，你想阻塞和非阻塞都可以，看起来似乎是完美的。
那问题是什么呢？可能我们最先发现的问题是，无法告诉我哪些fd已经准备好，还是需要我们自己去确认。这一步似乎系统也能知道，为什么不把这部分工作也做掉？
尽管POSIX定义了它自己的变体pselect，但是基本的行为是一样的，刚才我们说的问题pselect也没做。

#### 为什么需要poll
开玩笑得说，为什么选择（select）有了，还要调查（poll），看起来这两则没有什么本质区别，但是确实有点区别。和select一样，poll可以指定需要监控的fd数量。
但是如果数量是N，那么select会监听0~N-1的fd，但是poll是可以指定的，这N个fd没什么限制，这显然增强了灵活性，而且数量也更多了，不再受到1024的限制。
最后poll会把发生的event单独存放到revent中，而不是和select一样，回去影响入参数，确实，变强大了一点，但是并不是很大的飞跃。

#### 什么是epoll
epoll是什么，epoll就是event-poll，select是同步的IO多路复用，poll也类似，都是等待IO就绪。比较epoll和poll的用法，我们可以知道。
poll是基于fd的，关注的event和收到的event都是围绕fd来划分，返回值也是告诉你，有多少个fd收到event。
但是，epoll的视角变了，它成了一套机制，这套机制围绕event，而不是fd，以event作为关注点。
因为epoll的核心接口epoll_wait()以event作为参数，而不再是fd，最多可以收集多少events，放在那里，都在参数中指定。
其实模式没有变化，一致等待，阻塞一段时间，还是马上返回，和select/poll是样的，epoll可有这些行为可选。

epoll的使用需要先创建一个epoll-instance，这个和select和poll不一样，但是epoll也是支持阻塞等待的。
在默认情况下epoll的水平触发模式和poll功能是类似的，在用poll的地方都可以用epoll。只是epoll是一种更快的poll。

#### 为什么需要epoll
上面说道，epoll是一种更快的poll，但是只是因为快么？为什么需要epoll，原因有两个：

（1）epoll是linux特有的多路并发epoll支持边沿触发。

什么是边沿触发？man epoll里有个例子，简单来说就是。你调用epoll_wait()时，有数据就绪，你读取了一部分数据（还剩下一部分没有读取），然后你再次epoll_wait()时会卡主。
如果说水平触发，你的epoll_wait会马上返回，这样你就可以继续读取没读完的数据。所以边沿触发模式下，你的epoll_wait()需要有事件来触发。
当fd的状态发生变化时，event才会被发送，而不管是否还是有数据可用。

（2）对大规模文件描述符监控的支持。
这是因为epoll改变了监控机制，原先是轮询，现在是事件触发，虽然都是内核在支持，但是方式已经不一样。
现在内核可以更加高效，所以就可以支持大规模的fd集合。



最后说几个细节：

#### 为什么man epoll显示和man select/poll不一样
如果我们man一下select，或者pool，我们会发现这两个接口都是man(2)下的，但是我们man epoll，显示的确是在man(7)下，并显示epoll - I/O event notification facility。
因为epoll已经不是一个单独的接口，这代表一套机制，我们要是查看具体的epoll接口，比如epoll_create，那么就可以在man(2)下找到。


#### epoll的Ask And Question 很有意思
（1）epoll可以注册多个相同的fd到一个epoll-instance中么？一般是不可以的，但是duplicate-fd是可以加到同一个epoll-instance中的。
为什么这么做，因为这样，如果不同的fd设置不通过的event掩码，那么可以用不同的fd来处理不同的event，这样可以对event进行过滤。

（2）相同的fd可以注册到多个不同的epoll-instance中么？可以的。毕竟这样更通用。

（3）一个fd的关闭，会不会导致这个fd从相关的所有epoll-set中移除？
